Param(
    [ValidateNotNullOrEmpty()]
    [Parameter(Mandatory=$True)]
    [string] $SUBSCRIPTION_ID,
    [ValidateNotNullOrEmpty()]
    [Parameter(Mandatory=$True)]
    [string] $RESOURCE_GROUP,
    [ValidateNotNullOrEmpty()]
    [Parameter(Mandatory=$True)]
    [string] $TENANT_ID,
    [ValidateNotNullOrEmpty()]
    [Parameter(Mandatory=$True)]
    [string] $LOCATION,
    [ValidateNotNullOrEmpty()]
    [Parameter(Mandatory=$True)]
    [string] $AUTH_TYPE,
    [ValidateNotNullOrEmpty()]
    [Parameter(Mandatory=$True)]
    [string] $CORRELATION_ID,
    [ValidateNotNullOrEmpty()]
    [Parameter(Mandatory=$True)]
    [string] $CLOUD,
    [ValidateNotNullOrEmpty()]
    [Parameter(Mandatory=$True)]
    [string] $ServicePrincipalId,
    [ValidateNotNullOrEmpty()]
    [Parameter(Mandatory=$True)]
    [string] $ServicePrincipalClientSecret,
    [ValidateNotNullOrEmpty()]
    [Parameter(Mandatory=$True)]
)

#
# Powershell Configurations
#

# Note: Because the $ErrorActionPreference is "Stop", this script will stop on first failure.  
$ErrorActionPreference = "stop"

Enable-PSRemoting -Force -SkipNetworkProfileCheck

# Ensure that current process can run scripts. 
Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force 

###################################################################################################

#
# Custom Configurations
#

# Location of the log files
$ScriptLogFolder = Join-Path $PSScriptRoot -ChildPath $("ArcEnable-" + [System.DateTime]::Now.ToString("yyyy-MM-dd-HH-mm-ss"))
$ScriptLog = Join-Path -Path $ScriptLogFolder -ChildPath "ArcEnable.log"

# Default exit code
$ExitCode = 0

##################################################################################################

# 
# Description:
#  - Creates the folder structure which'll be used for dumping logs generated by this script and
#    the logon task.
#
# Parameters:
#  - N/A.
#
# Return:
#  - N/A.
#
# Notes:
#  - N/A.
#

function InitializeFolders
{
    if ($false -eq (Test-Path -Path $ScriptLogFolder))
    {
        New-Item -Path $ScriptLogFolder -ItemType directory | Out-Null
    }
}

##################################################################################################

# 
# Description:
#  - Writes specified string to the console as well as to the script log (indicated by $ScriptLog).
#
# Parameters:
#  - $message: The string to write.
#
# Return:
#  - N/A.
#
# Notes:
#  - N/A.
#

function WriteLog
{
    Param(
        <# Can be null or empty #> $message
    )

    $timestampedMessage = $("[" + [System.DateTime]::Now + "] " + $message) | % {  
        Write-Host -Object $_
        Out-File -InputObject $_ -FilePath $ScriptLog -Append
    }
}

##################################################################################################

#
# 
#

try
{
    #
    InitializeFolders

	[System.Environment]::SetEnvironmentVariable("MSFT_ARC_TEST",'true', [System.EnvironmentVariableTarget]::Machine)
	Set-Service WindowsAzureGuestAgent -StartupType Disabled -Verbose
	Stop-Service WindowsAzureGuestAgent -Force -Verbose
	New-NetFirewallRule -Name BlockAzureIMDS -DisplayName "Block access to Azure IMDS" -Enabled True -Profile Any -Direction Outbound -Action Block -RemoteAddress 169.254.169.254

    $env:SUBSCRIPTION_ID = $SUBSCRIPTION_ID;
    $env:RESOURCE_GROUP = $RESOURCE_GROUP;
    $env:TENANT_ID = $TENANT_ID;
    $env:LOCATION = $LOCATION;
    $env:AUTH_TYPE = $AUTH_TYPE;
    $env:CORRELATION_ID = $CORRELATION_ID;
    $env:CLOUD = $CLOUD;
    

    [Net.ServicePointManager]::SecurityProtocol = [Net.ServicePointManager]::SecurityProtocol -bor 3072;
    Invoke-WebRequest -UseBasicParsing -Uri "https://aka.ms/azcmagent-windows" -TimeoutSec 30 -OutFile "$env:TEMP\install_windows_azcmagent.ps1";
    & "$env:TEMP\install_windows_azcmagent.ps1";
    if ($LASTEXITCODE -ne 0) { exit 1; }
    & "$env:ProgramW6432\AzureConnectedMachineAgent\azcmagent.exe" connect --service-principal-id "$ServicePrincipalId" --service-principal-secret "$ServicePrincipalClientSecret" --resource-group "$env:RESOURCE_GROUP" --tenant-id "$env:TENANT_ID" --location "$env:LOCATION" --subscription-id "$env:SUBSCRIPTION_ID" --cloud "$env:CLOUD" --correlation-id "$env:CORRELATION_ID";
}
catch
{
    if (($null -ne $Error[0]) -and ($null -ne $Error[0].Exception) -and ($null -ne $Error[0].Exception.Message))
    {
        $errMsg = $Error[0].Exception.Message
        WriteLog $errMsg
        Write-Host $errMsg
    }
	
	$logBody = @{subscriptionId="$env:SUBSCRIPTION_ID";resourceGroup="$env:RESOURCE_GROUP";tenantId="$env:TENANT_ID";location="$env:LOCATION";correlationId="$env:CORRELATION_ID";authType="$env:AUTH_TYPE";operation="onboarding";messageType=$_.FullyQualifiedErrorId;message="$_";};
    Invoke-WebRequest -UseBasicParsing -Uri "https://gbl.his.arc.azure.com/log" -Method "PUT" -Body ($logBody | ConvertTo-Json) | out-null;
    Write-Host  -ForegroundColor red $_.Exception;

    # Important note: Throwing a terminating error (using $ErrorActionPreference = "stop") still returns exit 
    # code zero from the powershell script. The workaround is to use try/catch blocks and return a non-zero 
    # exit code from the catch block. 
    $ExitCode = -1
}

finally
{
    WriteLog $("This output log has been saved to: " + $ScriptLog)

    WriteLog $("Exiting with " + $ExitCode)
    exit $ExitCode
}
